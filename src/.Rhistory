mutate(Lseq=sub("\\..*","",tmp)) %>%
rename(AccID = leading.protein)
write.csv(lkup, "../results/lkup.csv")
saveRDS(lkup, "../results/lkup.rds")
################################################################################
##### Load and clean the ref dataset.
orig_ref <- read.fasta("../../data/uniprot-all.fasta", seqtype = "AA", as.string = T)
ref <- data.frame(AccID = getName(orig_ref), Rseq = rapply(getSequence(orig_ref, as.string = T), c)) %>%
### Clean AccID.
mutate(AccID = substr(as.character(AccID), 4, 9)) %>%
### Clean Rseq.
mutate(Rseq = toupper(Rseq)) %>%
### Remove duplicates.
distinct(AccID, Rseq)
### Save the clean version.
write.csv(ref,"../results/ref.csv")
saveRDS(ref, "../results/ref.rds")
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
View()
combo %>%
group_by(Rseq) %>%
filter(!duplicated(Lseq)) %>%
View()
combo %>%
group_by(Rseq)
combo <- merge(lkup, ref, by = "AccID") %>%
View()
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID")
combo
class(combo)
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID")
### Keep obs with unique values in LSeq and Rseq only.
combo %>%
group_by(Rseq)
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID")
### Keep obs with unique values in LSeq and Rseq only.
combo %>%
group_by(Rseq) %>%
filter(!duplicated(Lseq)) %>%
View()
combo %>%
rep(length(combo))
combo %>%
rep(2*length(combo))
combo <- combo %>%
rep(2*length(combo))
combo
combo <- combo[rep(row.names(combo),combo$AccID),]
combo <- combo[rep(row.names(combo),combo$AccID),:]
combo %>%
rbind(combo)
combo %>%
rbind(combo) %>%
View()
combo
combo %>%
rep(combo)
combo <- combo[rep(row.names(combo),2),]
combo <- combo[rep(row.names(combo),2),1:length(combo)]
?seq_len
combo <- combo[rep(row.names(combo),each = 2),]
combo <- combo[rep(combo),each = 2),]
combo <- combo[rep(combo,each = 2),]
combo <- combo[rep(combo[,], each = 2),]
sapply(combo, rep.int, 2)
sapply(combo, rep.int, 2) %>%
group_by(Rseq) %>%
filter(!duplicated(Lseq)) %>%
View()
sapply(combo, rep.int, 2) %>%
as.data.frame() %>%
group_by(Rseq) %>%
filter(!duplicated(Lseq)) %>%
View()
sapply(combo, rep.int, 2) %>%
View()
sapply(combo, rep.int, 2) %>%
select(combo$.*)
coredata(x)[rep(seq(nrow(x)),2),]
sapply(x, rep.int, times=2)
sapply(combo, rep.int, times=2)
sapply(combo, rep.int, times=1)
sapply(combo, rep.int, times=1) %>%
View()
lapply(combo, rep.int, times=1) %>%
View()
sapply(combo, rep.int, times=1) %>%
View()
sapply(combo, rep.int, times=1) %>%
dim()
dim(combo)
dim(as.data.frame(combo))
dim(combo)
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID")
dim(combo)
combo <- combo[!duplicated(combo[, c('LSeq', 'Rseq')]), ] # no change
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID")
as.data.frame(combo)
### Keep obs with unique values in LSeq and Rseq only.
# combo
#   as.data.frame() %>%
#   group_by(Rseq) %>%
#   filter(!duplicated(Lseq)) %>%
#   View()
combo <- combo[!duplicated(combo[, c('LSeq', 'Rseq')]), ] # no change
combo <- [rbind(combo,combo),]
combo <- combo[rbind(combo,combo),]
rep(combo, each=N)
rep(combo, each=2)
dim(rep(combo, each=2))
rep(combo, each=2) %>%
as.data.frame() %>%
dim()
?rep
combo
dim(combo)
combo %>%
rep(2)
combo %>%
rep(2) %>%
dim()
combo %>%
rep(2) %>%
as.data.frame() %>%
dim()
combo %>%
dim()
combo <- combo[rep(combo,2),]
combo %>%
class()
combo %>%
typeof()
combo <- as.data.frame(combo)
typeof()
typeof(combo)
combo <- data.frame(combo)
typeof(combo)
combo <- combo[rep(row.names(combo),2),]
combo
dim(combo)
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID")
### Keep obs with unique values in LSeq and Rseq only.
combo <- combo[rep(row.names(combo),2),] %>%
group_by(Rseq) %>%
filter(!duplicated(Lseq)) %>%
View()
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
### Keep obs with unique values in LSeq and Rseq only.
#combo <- combo[rep(row.names(combo),2),] %>%
group_by(Rseq) %>%
filter(!duplicated(Lseq)) %>%
View()
?intersect
mtcars$model <- rownames(mtcars)
first <- mtcars[1:20, ]
second <- mtcars[10:32, ]
intersect(first, second)
union(first, second)
setdiff(first, second)
setdiff(second, first)
union_all(first, second)
setequal(mtcars, mtcars[32:1, ])
length(intersect(combo$AccID, lkup$AccID)) == length(unique(lkup$AccID))
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
### Keep obs with unique values in LSeq and Rseq only.
# group_by(Rseq) %>%
# filter(!duplicated(Lseq)) %>%
### Check if all AccIDs from lkup are in combo. Must be TRUE.
length(intersect(combo$AccID, lkup$AccID)) == length(unique(lkup$AccID))
length(intersect(combo$AccID, lkup$AccID)) == length(unique(lkup$AccID))
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID")
### Keep obs with unique values in LSeq and Rseq only.
# group_by(Rseq) %>%
# filter(!duplicated(Lseq)) %>%
### Check if all AccIDs from lkup are in combo. Must be TRUE.
length(intersect(combo$AccID, lkup$AccID)) == length(unique(lkup$AccID))
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
dim()
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
dim() %>%
print()
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
### Keep obs with unique values in LSeq and Rseq only.
group_by(Rseq) %>%
filter(!duplicated(Lseq)) %>%
dim()
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
### Keep obs with unique values in LSeq and Rseq only.
group_by(Rseq) %>%
filter(!duplicated(Lseq)) %>%
dim() %>%
print()
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
### Keep obs with unique values in LSeq and Rseq only.
group_by(Rseq) %>%
filter(!duplicated(Lseq))
length(intersect(combo$AccID, lkup$AccID)) == length(unique(lkup$AccID))
ori_lkup <- read.csv("../data/testData.csv")
# select only relevant columns. the name "leading protein" is converted to "leading.protein" by R default
lkup <- ori_lkup %>%
select(peptide,leading.protein) %>%
# filter out proteins with no sequence information, doesn't matter for test but will become important for real data
filter(peptide!="") %>%
# create new column indicating whether the N-terminus is blocked before tryptic digestion
mutate(Ncapped = 0)
lkup$Ncapped[contains("n",FALSE,lkup$peptide)] <- 1
# variable that stores the peptide sequence in character
pepseq <- as.character(lkup$peptide)
# temp variable for formatting sequence
tmp <- sub(".?\\.","",pepseq)
tmp <- sub("n\\[.*\\]","",tmp)
# add the formatted sequence as a new column named Lseq
lkup <- lkup %>%
mutate(Lseq=sub("\\..*","",tmp)) %>%
rename(AccID = leading.protein)
write.csv(lkup, "../results/lkup.csv")
saveRDS(lkup, "../results/lkup.rds")
################################################################################
##### Load and clean the ref dataset.
orig_ref <- read.fasta("../../data/uniprot-all.fasta", seqtype = "AA", as.string = T)
ref <- data.frame(AccID = getName(orig_ref), Rseq = rapply(getSequence(orig_ref, as.string = T), c)) %>%
### Clean AccID.
mutate(AccID = substr(as.character(AccID), 4, 9)) %>%
### Clean Rseq.
mutate(Rseq = toupper(Rseq)) %>%
### Remove duplicates.
distinct(AccID, Rseq)
### Save the clean version.
write.csv(ref,"../results/ref.csv")
saveRDS(ref, "../results/ref.rds")
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
### Keep obs with unique values in LSeq and Rseq only.
group_by(Rseq) %>%
filter(!duplicated(Lseq))
### Check if all AccIDs from lkup are in combo. Must be TRUE.
length(intersect(combo$AccID, lkup$AccID)) == length(unique(lkup$AccID))
length(intersect(combo$AccID, as.character(ref$AccID))) == length(unique(ref$AccID))
lapply(c("dplyr", "seqinr", "tidyr", "ggplot2","assert_that"), library, character.only = T)
lapply(c("dplyr", "seqinr", "tidyr", "ggplot2","assertthat"), library, character.only = T)
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
### Keep obs with unique values in LSeq and Rseq only.
group_by(Rseq) %>%
filter(!duplicated(Lseq))
### Check if all AccIDs from lkup are in combo. Must be TRUE.
length(intersect(combo$AccID, lkup$AccID)) == length(unique(lkup$AccID)) %>%
assert_that()
assert_that(length(intersect(combo$AccID, lkup$AccID)) == length(unique(lkup$AccID)))
assert_that(length(intersect(combo$AccID, as.character(ref$AccID))) != length(unique(ref$AccID)))
### Check if all AccIDs from ref are in combo. Must be FALSE.
assert_that(length(intersect(combo$AccID, as.character(ref$AccID))) != length(unique(ref$AccID)))
### Set Match to 1 if LSeq is a substring of Rseq; 0 otherwise.
combo %>%
mutate(Match = Lseq %in% Rseq)
### Check if all AccIDs from ref are in combo. Must be FALSE.
assert_that(length(intersect(combo$AccID, as.character(ref$AccID))) != length(unique(ref$AccID)))
### Set Match to 1 if LSeq is a substring of Rseq; 0 otherwise.
combo %>%
mutate(Match = Lseq %in% Rseq) %>%
View()
combo$Match <- mapply(grepl, combo$LSeq, combo$Rseq) %>%
View()
assert_that(sum(combo$Match) == nrow(combo))
# read csv file from test data
ori_lkup <- read.csv("../data/testData.csv")
# select only relevant columns. the name "leading protein" is converted to "leading.protein" by R default
lkup <- ori_lkup %>%
select(peptide,leading.protein) %>%
# filter out proteins with no sequence information, doesn't matter for test but will become important for real data
filter(peptide!="") %>%
# create new column indicating whether the N-terminus is blocked before tryptic digestion
mutate(Ncapped = 0)
lkup$Ncapped[contains("n",FALSE,lkup$peptide)] <- 1
# variable that stores the peptide sequence in character
pepseq <- as.character(lkup$peptide)
# temp variable for formatting sequence
tmp <- sub(".?\\.","",pepseq)
tmp <- sub("n\\[.*\\]","",tmp)
# add the formatted sequence as a new column named Lseq
lkup <- lkup %>%
mutate(Lseq=sub("\\..*","",tmp)) %>%
rename(AccID = leading.protein)
write.csv(lkup, "../results/lkup.csv")
saveRDS(lkup, "../results/lkup.rds")
################################################################################
##### Load and clean the ref dataset.
orig_ref <- read.fasta("../../data/uniprot-all.fasta", seqtype = "AA", as.string = T)
ref <- data.frame(AccID = getName(orig_ref), Rseq = rapply(getSequence(orig_ref, as.string = T), c)) %>%
### Clean AccID.
mutate(AccID = substr(as.character(AccID), 4, 9)) %>%
### Clean Rseq.
mutate(Rseq = toupper(Rseq)) %>%
### Remove duplicates.
distinct(AccID, Rseq)
### Save the clean version.
write.csv(ref,"../results/ref.csv")
saveRDS(ref, "../results/ref.rds")
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
### Keep obs with unique values in LSeq and Rseq only.
group_by(Rseq) %>%
filter(!duplicated(Lseq))
### Check if all AccIDs from lkup are in combo. Must be TRUE.
assert_that(length(intersect(combo$AccID, lkup$AccID)) == length(unique(lkup$AccID)))
### Check if all AccIDs from ref are in combo. Must be FALSE.
assert_that(length(intersect(combo$AccID, as.character(ref$AccID))) != length(unique(ref$AccID)))
combo$Match <- mapply(grepl, combo$LSeq, combo$Rseq)
### Check if all AccIDs from ref are in combo. Must be FALSE.
assert_that(length(intersect(combo$AccID, as.character(ref$AccID))) != length(unique(ref$AccID)))
### Set Match to 1 if Lseq is a substring of Rseq; 0 otherwise.
combo %>%
mutate(Match = Lseq %in% Rseq) %>%
View()
### Check if all AccIDs from ref are in combo. Must be FALSE.
assert_that(length(intersect(combo$AccID, as.character(ref$AccID))) != length(unique(ref$AccID)))
### Set Match to 1 if Lseq is a substring of Rseq; 0 otherwise.
combo %>%
mutate(Match = Lseq %in% as.character(Rseq)) %>%
View()
# read csv file from test data
ori_lkup <- read.csv("../data/testData.csv")
# select only relevant columns. the name "leading protein" is converted to "leading.protein" by R default
lkup <- ori_lkup %>%
select(peptide,leading.protein) %>%
# filter out proteins with no sequence information, doesn't matter for test but will become important for real data
filter(peptide!="") %>%
# create new column indicating whether the N-terminus is blocked before tryptic digestion
mutate(Ncapped = 0)
lkup$Ncapped[contains("n",FALSE,lkup$peptide)] <- 1
# variable that stores the peptide sequence in character
pepseq <- as.character(lkup$peptide)
# temp variable for formatting sequence
tmp <- sub(".?\\.","",pepseq)
tmp <- sub("n\\[.*\\]","",tmp)
# add the formatted sequence as a new column named Lseq
lkup <- lkup %>%
mutate(Lseq=sub("\\..*","",tmp)) %>%
rename(AccID = leading.protein)
write.csv(lkup, "../results/lkup.csv")
saveRDS(lkup, "../results/lkup.rds")
################################################################################
##### Load and clean the ref dataset.
orig_ref <- read.fasta("../../data/uniprot-all.fasta", seqtype = "AA", as.string = T)
ref <- data.frame(AccID = getName(orig_ref), Rseq = rapply(getSequence(orig_ref, as.string = T), c)) %>%
### Clean AccID.
mutate(AccID = substr(as.character(AccID), 4, 9)) %>%
### Clean Rseq.
mutate(Rseq = toupper(Rseq)) %>%
### Remove duplicates.
distinct(AccID, Rseq)
### Save the clean version.
write.csv(ref,"../results/ref.csv")
saveRDS(ref, "../results/ref.rds")
##### Merge the lkup and ref datasets by AccID. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "AccID") %>%
### Keep obs with unique values in Lseq and Rseq only.
group_by(Rseq) %>%
filter(!duplicated(Lseq))
### Check if all AccIDs from lkup are in combo. Must be TRUE.
assert_that(length(intersect(combo$AccID, lkup$AccID)) == length(unique(lkup$AccID)))
### Check if all AccIDs from ref are in combo. Must be FALSE.
assert_that(length(intersect(combo$AccID, as.character(ref$AccID))) != length(unique(ref$AccID)))
### Set Match to 1 if Lseq is a substring of Rseq; 0 otherwise.
combo$Match <- mapply(grepl, combo$Lseq, combo$Rseq)
View(combo)
combo %>%
mutate(Match = grepl(Lseq,Rseq)) %>%
View()
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "Accid") %>%
### Keep obs with unique values in Lseq and Rseq only.
group_by(Rseq) %>%
filter(!duplicated(Lseq))
### Check if all Accids from lkup are in combo. Must be TRUE.
assert_that(length(intersect(combo$Accid, lkup$Accid)) == length(unique(lkup$Accid)))
### Check if all Accids from ref are in combo. Must be FALSE.
assert_that(length(intersect(combo$Accid, as.character(ref$Accid))) != length(unique(ref$Accid)))
### Set Match to 1 if Lseq is a substring of Rseq; 0 otherwise.
combo %>%
mutate(Match = grepl(Lseq,Rseq)) %>%
filter(Match == TRUE) %>%
mutate(Llen = nchar(Lseq),
Rlen = nchar(Rseq),
Lstart = regexpr(Lseq,Rseq,fixed = TRUE),
Lend = Lstart + Llen -1) %>%
View()
ori_lkup <- read.csv("../data/testData.csv")
# select only relevant columns. the name "leading protein" is converted to "leading.protein" by R default
lkup <- ori_lkup %>%
select(peptide,leading.protein) %>%
# filter out proteins with no sequence information, doesn't matter for test but will become important for real data
filter(peptide!="") %>%
# create new column indicating whether the N-terminus is blocked before tryptic digestion
mutate(Ncapped = 0)
lkup$Ncapped[contains("n",FALSE,lkup$peptide)] <- 1
# variable that stores the peptide sequence in character
pepseq <- as.character(lkup$peptide)
# temp variable for formatting sequence
tmp <- sub(".?\\.","",pepseq)
tmp <- sub("n\\[.*\\]","",tmp)
# add the formatted sequence as a new column named Lseq
lkup <- lkup %>%
mutate(Lseq=as.character(sub("\\..*","",tmp))) %>%
rename(Accid = leading.protein)
write.csv(lkup, "../results/lkup.csv")
saveRDS(lkup, "../results/lkup.rds")
################################################################################
##### Load and clean the ref dataset.
orig_ref <- read.fasta("../../data/uniprot-all.fasta", seqtype = "AA", as.string = T)
ref <- data.frame(Accid = getName(orig_ref), Rseq = rapply(getSequence(orig_ref, as.string = T), c)) %>%
### Clean Accid.
mutate(Accid = substr(as.character(Accid), 4, 9)) %>%
### Clean Rseq.
mutate(Rseq = as.character(toupper(Rseq))) %>%
### Remove duplicates.
distinct(Accid, Rseq)
### Save the clean version.
write.csv(ref,"../results/ref.csv")
saveRDS(ref, "../results/ref.rds")
##### Merge the lkup and ref datasets by Accid. Do checks.
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "Accid") %>%
### Keep obs with unique values in Lseq and Rseq only.
group_by(Rseq) %>%
filter(!duplicated(Lseq))
### Check if all Accids from lkup are in combo. Must be TRUE.
assert_that(length(intersect(combo$Accid, lkup$Accid)) == length(unique(lkup$Accid)))
### Check if all Accids from ref are in combo. Must be FALSE.
assert_that(length(intersect(combo$Accid, as.character(ref$Accid))) != length(unique(ref$Accid)))
### Set Match to 1 if Lseq is a substring of Rseq; 0 otherwise.
combo %>%
mutate(Match = grepl(Lseq,Rseq)) %>%
filter(Match == TRUE) %>%
mutate(Llen = nchar(Lseq),
Rlen = nchar(Rseq),
Lstart = regexpr(Lseq,Rseq,fixed = TRUE),
Lend = Lstart + Llen -1) %>%
View()
combo %>%
mutate(Match = grepl(Lseq,Rseq)) %>%
filter(Match == TRUE)
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "Accid") %>%
### Keep obs with unique values in Lseq and Rseq only.
distinct(Lseq,Rseq)
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "Accid") %>%
### Keep obs with unique values in Lseq and Rseq only.
distinct(Lseq,Rseq) %>%
View()
lkup <- read.csv("../results/lkup.csv")
ref <- read.csv("../results/ref.csv")
combo <- merge(lkup, ref, by = "Accid") %>%
### Keep obs with unique values in Lseq and Rseq only.
filter(distinct(Lseq,Rseq)) %>%
View()
ref <- read.csv("../results/ref.csv")
head(ref)
ref[2]
ref[3]
rm(list=ls())
q()
